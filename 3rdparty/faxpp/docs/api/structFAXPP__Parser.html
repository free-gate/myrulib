<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Faxpp 0.3 Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<a style="float:right;" href="http://sourceforge.net/projects/faxpp"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=201903&amp;type=2" border="0" alt="SourceForge.net Logo" /></a>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>FAXPP_Parser Struct Reference</h1><!-- doxytag: class="FAXPP_Parser" -->The parser structure.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="parser_8h-source.html">parser.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#8bbd54a6e2d37f54b25ca1e986fc6b85">FAXPP_create_parser</a> (<a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268">FAXPP_ParseMode</a> mode, <a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a> encode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a parser object.  <a href="#8bbd54a6e2d37f54b25ca1e986fc6b85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#88cad603c0583aaf87f1bfaadb5197c1">FAXPP_free_parser</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a parser object.  <a href="#88cad603c0583aaf87f1bfaadb5197c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#2f0f57d3017672bbf89aebdd1c6a5b82">FAXPP_set_null_terminate</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, unsigned int boolean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether the parser will null terminate the strings in the event values.  <a href="#2f0f57d3017672bbf89aebdd1c6a5b82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#97d9fe261f063b0bd5d2b933f8ec9ed8">FAXPP_set_normalize_attrs</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, unsigned int boolean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether the parser will normalize attributes values into a single string.  <a href="#97d9fe261f063b0bd5d2b933f8ec9ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#e100f97e382d89ef9e819adc4fd7550f">FAXPP_set_encode</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a> encode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the transcoder that the parser will use when encoding event values.  <a href="#e100f97e382d89ef9e819adc4fd7550f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#f86972fbc5e3115290c9a8840fc7d4e8">FAXPP_get_decode</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current FAXPP_DecodeFunction that the parser is using.  <a href="#f86972fbc5e3115290c9a8840fc7d4e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#071e23490ca525b178d0e2f8e7d8e918">FAXPP_set_decode</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a> decode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FAXPP_DecodeFunction that the parser uses to decode the XML document.  <a href="#071e23490ca525b178d0e2f8e7d8e918"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#b6f657afb016e6e81e830297ad1c2763">FAXPP_get_base_uri</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the base URI for the file currently being parsed.  <a href="#b6f657afb016e6e81e830297ad1c2763"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#d7abd90dc4bc29a4e5002a3486563593">FAXPP_set_base_uri</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *base_uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the base URI for the file currently being parsed.  <a href="#d7abd90dc4bc29a4e5002a3486563593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#3f81757b5a659c174d5f6cb712a4d96c">FAXPP_set_base_uri_str</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, const char *base_uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the base URI for the file currently being parsed.  <a href="#3f81757b5a659c174d5f6cb712a4d96c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#421db983eba7bea2b4faac0d9e048e50">FAXPP_set_external_entity_callback</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#e933a0086290a065b22874d9eeb80a54">FAXPP_ExternalEntityCallback</a> callback, void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters a reference to an external parsed entity.  <a href="#421db983eba7bea2b4faac0d9e048e50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#7aa280c7b5a002c4a97ea8b99ffe7cab">FAXPP_init_parse</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, void *buffer, unsigned int length, unsigned int done)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the parser to parse the given buffer.  <a href="#7aa280c7b5a002c4a97ea8b99ffe7cab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#1b6319866100a7fe51309bd548dd9d86">FAXPP_init_parse_file</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, FILE *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the parser to parse the given file.  <a href="#1b6319866100a7fe51309bd548dd9d86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#229ebc0c0fdd6adec059d009b1cf110b">FAXPP_init_parse_callback</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a> callback, void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the parser to parse using the given read callback.  <a href="#229ebc0c0fdd6adec059d009b1cf110b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#1471e0670ded3180080ed9cc246d2828">FAXPP_parse_external_entity</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, void *buffer, unsigned int length, unsigned int done)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts parsing to parse the external entity in the given buffer.  <a href="#1471e0670ded3180080ed9cc246d2828"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#afe116d82fe02a8266929d39b6ec0409">FAXPP_parse_external_entity_file</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, FILE *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts parsing to parse the external entity from the given file.  <a href="#afe116d82fe02a8266929d39b6ec0409"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#255d9071f6a54574c886d1fd1db4f29e">FAXPP_parse_external_entity_callback</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, <a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a> callback, void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts parsing to parse the external entity using the given read callback.  <a href="#255d9071f6a54574c886d1fd1db4f29e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#f55413e143d7a8aa424a0004e7cb351e">FAXPP_release_buffer</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, void **buffer_position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instructs the parser to release any dependencies it has on it's current buffer.  <a href="#f55413e143d7a8aa424a0004e7cb351e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#427686a8cf6337802d9d961d07a5606d">FAXPP_continue_parse</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, void *buffer, unsigned int length, unsigned int done)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a new buffer for the parser to continue parsing.  <a href="#427686a8cf6337802d9d961d07a5606d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#e743444bca7395430011eea17758211a">FAXPP_next_event</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses the next event, placing the information for it into the current event.  <a href="#e743444bca7395430011eea17758211a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structFAXPP__Event.html">FAXPP_Event</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#4dce77addd1cba6869c6a07733b939cc">FAXPP_get_current_event</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current event produced by the parser when <a class="el" href="structFAXPP__Parser.html#e743444bca7395430011eea17758211a" title="Parses the next event, placing the information for it into the current event.">FAXPP_next_event()</a> was called.  <a href="#4dce77addd1cba6869c6a07733b939cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#d3929884306c99be9a2786936e5c7c77">FAXPP_lookup_namespace_uri</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *prefix, <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up the given prefix in the parser's namespace mappings, returning the namespace URI in the uri parameter.  <a href="#d3929884306c99be9a2786936e5c7c77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#c35b9fb452dc8b33c173543f83d1837d">FAXPP_get_nesting_level</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current element nesting level in the XML document.  <a href="#c35b9fb452dc8b33c173543f83d1837d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#81aff48f3f81c0ea684b3260b2cd8b74">FAXPP_get_error_line</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the line that the current error occured on.  <a href="#81aff48f3f81c0ea684b3260b2cd8b74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFAXPP__Parser.html#d39353aed0a2cd0ddaccfb910f9220d1">FAXPP_get_error_column</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the column that the current error occured on.  <a href="#d39353aed0a2cd0ddaccfb910f9220d1"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The parser structure. 
<p>
Details of the structure are private.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="parser_8h.html">parser.h</a> </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>

<p>
<a class="el" href="entity__resolver_8c-example.html#_a0">entity_resolver.c</a>, and <a class="el" href="parser__example_8c-example.html#_a0">parser_example.c</a>.</dl><hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="8bbd54a6e2d37f54b25ca1e986fc6b85"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_create_parser" ref="8bbd54a6e2d37f54b25ca1e986fc6b85" args="(FAXPP_ParseMode mode, FAXPP_Transcoder encode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> * FAXPP_create_parser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268">FAXPP_ParseMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a>&nbsp;</td>
          <td class="paramname"> <em>encode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a parser object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The type of checks the parser should perform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encode</em>&nbsp;</td><td>The transcoder to use when encoding event values</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the parser object, or 0 if out of memory. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a1">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="88cad603c0583aaf87f1bfaadb5197c1"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_free_parser" ref="88cad603c0583aaf87f1bfaadb5197c1" args="(FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_free_parser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees a parser object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to free </td></tr>
  </table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a15">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="2f0f57d3017672bbf89aebdd1c6a5b82"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_null_terminate" ref="2f0f57d3017672bbf89aebdd1c6a5b82" args="(FAXPP_Parser *parser, unsigned int boolean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_null_terminate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>boolean</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the parser will null terminate the strings in the event values. 
<p>
The default is not to null terminate strings, as this is generally more efficient.<p>
Setting this parameter whilst a parse is in progress has undefined results.<p>
Null terminating the event strings will involve copying the strings, and so will be slower where copying strings was not otherwise necessary. The <a class="el" href="structFAXPP__Text.html#0020dd9d52a282ad375ab35352b262ca" title="The length of the string in bytes.">FAXPP_Text::len</a> field will not include the null in it's count of bytes, and so will be identical whether the parser is null terminating strings or not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boolean</em>&nbsp;</td><td>Whether to null terminate the event strings or not </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="97d9fe261f063b0bd5d2b933f8ec9ed8"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_normalize_attrs" ref="97d9fe261f063b0bd5d2b933f8ec9ed8" args="(FAXPP_Parser *parser, unsigned int boolean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_normalize_attrs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>boolean</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the parser will normalize attributes values into a single string. 
<p>
This option is off by default for NO_CHECKS_PARSE_MODE, and on for other parser modes.<p>
The XML specification requires conformant parsers to normalize attribute values by expanding entity references and turning all whitespace to &amp;x20; characters. This option will have no effect on a parser in NO_CHECKS_PARSE_MODE, since this mode will never normalize attribute values.<p>
Setting this parameter whilst a parse is in progress has undefined results.<p>
Normalizing attribute values will involve copying the strings, and so will be slower where copying strings was not otherwise necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boolean</em>&nbsp;</td><td>Whether to normalize attribute values </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e100f97e382d89ef9e819adc4fd7550f"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_encode" ref="e100f97e382d89ef9e819adc4fd7550f" args="(FAXPP_Parser *parser, FAXPP_Transcoder encode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_encode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a>&nbsp;</td>
          <td class="paramname"> <em>encode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the transcoder that the parser will use when encoding event values. 
<p>
Setting this parameter whilst a parse is in progress has undefined results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encode</em>&nbsp;</td><td>The transcoder to use when encoding event values </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f86972fbc5e3115290c9a8840fc7d4e8"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_get_decode" ref="f86972fbc5e3115290c9a8840fc7d4e8" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a> FAXPP_get_decode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current FAXPP_DecodeFunction that the parser is using. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The decode function </dd></dl>

</div>
</div><p>
<a class="anchor" name="071e23490ca525b178d0e2f8e7d8e918"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_decode" ref="071e23490ca525b178d0e2f8e7d8e918" args="(FAXPP_Parser *parser, FAXPP_DecodeFunction decode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_decode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>decode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the FAXPP_DecodeFunction that the parser uses to decode the XML document. 
<p>
This will typically be called when an encoding declaration is read, to switch to the correct decode function.<p>
This method can also be called after initialising the parser, to specify that the encoding for the document is known, and all other encoding hints should be ignored. Note that it is valid to call this method and proceed with a document parse when parser initialisation fails with the UNSUPPORTED_ENCODING error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decode</em>&nbsp;</td><td>The decode function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6f657afb016e6e81e830297ad1c2763"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_get_base_uri" ref="b6f657afb016e6e81e830297ad1c2763" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> * FAXPP_get_base_uri           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the base URI for the file currently being parsed. 
<p>
This is set by the user using <a class="el" href="structFAXPP__Parser.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a> or <a class="el" href="structFAXPP__Parser.html#3f81757b5a659c174d5f6cb712a4d96c" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri_str()</a>.<p>
The base URI returned will be in the encoding that it was provided in to the <a class="el" href="structFAXPP__Parser.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current base URI </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a12">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="d7abd90dc4bc29a4e5002a3486563593"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_base_uri" ref="d7abd90dc4bc29a4e5002a3486563593" args="(FAXPP_Parser *parser, const FAXPP_Text *base_uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_set_base_uri           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td>
          <td class="paramname"> <em>base_uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the base URI for the file currently being parsed. 
<p>
This is passed to the FAXPP_ExternalEntityCallback set using <a class="el" href="structFAXPP__Parser.html#421db983eba7bea2b4faac0d9e048e50" title="Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters...">FAXPP_set_external_entity_callback()</a>.<p>
A copy of the base_uri will be kept internally, so neither the <a class="el" href="structFAXPP__Text.html" title="The basic string type in faxpp.">FAXPP_Text</a> object nor the buffer it points to need exist after a call to <a class="el" href="structFAXPP__Parser.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a>. The encoding of the base URI is irrelevent to FAXPP - the base URI will be in the same encoding when it is passed back to the FAXPP_ExternalEntityCallback.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base_uri</em>&nbsp;</td><td>The base URI</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3f81757b5a659c174d5f6cb712a4d96c"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_base_uri_str" ref="3f81757b5a659c174d5f6cb712a4d96c" args="(FAXPP_Parser *parser, const char *base_uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_set_base_uri_str           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>base_uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the base URI for the file currently being parsed. 
<p>
This is passed to the FAXPP_ExternalEntityCallback set using <a class="el" href="structFAXPP__Parser.html#421db983eba7bea2b4faac0d9e048e50" title="Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters...">FAXPP_set_external_entity_callback()</a>.<p>
A copy of the base_uri will be kept internally, so the string need not exist after a call to <a class="el" href="structFAXPP__Parser.html#3f81757b5a659c174d5f6cb712a4d96c" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri_str()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base_uri</em>&nbsp;</td><td>The base URI</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="entity__resolver_8c-example.html#a7">entity_resolver.c</a>, and <a class="el" href="parser__example_8c-example.html#a7">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="421db983eba7bea2b4faac0d9e048e50"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_set_external_entity_callback" ref="421db983eba7bea2b4faac0d9e048e50" args="(FAXPP_Parser *parser, FAXPP_ExternalEntityCallback callback, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_external_entity_callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#e933a0086290a065b22874d9eeb80a54">FAXPP_ExternalEntityCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters a reference to an external parsed entity. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The callback function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The usuer data passed when the function is called </td></tr>
  </table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a4">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="7aa280c7b5a002c4a97ea8b99ffe7cab"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_init_parse" ref="7aa280c7b5a002c4a97ea8b99ffe7cab" args="(FAXPP_Parser *parser, void *buffer, unsigned int length, unsigned int done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_init_parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the parser to parse the given buffer. 
<p>
This will halt any parse that was already in progress.<p>
The buffer provided must remain valid and unchanged during the time that the parser is using it, since a copy of it is <em>not</em> made. The user remains responsible for deleting the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the start of the buffer to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the given buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>Set to non-zero if this is the last buffer from the input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1b6319866100a7fe51309bd548dd9d86"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_init_parse_file" ref="1b6319866100a7fe51309bd548dd9d86" args="(FAXPP_Parser *parser, FILE *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_init_parse_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the parser to parse the given file. 
<p>
This will halt any parse that was already in progress.<p>
The file provided must remain valid during the time that the parser is using it. The user remains responsible for closing the file after parsing has ended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file descriptor of the file to parse</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="229ebc0c0fdd6adec059d009b1cf110b"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_init_parse_callback" ref="229ebc0c0fdd6adec059d009b1cf110b" args="(FAXPP_Parser *parser, FAXPP_ReadCallback callback, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_init_parse_callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the parser to parse using the given read callback. 
<p>
This will halt any parse that was already in progress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The read callback function to use to retrieve the parse input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data to be passed to the callback function when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a5">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="1471e0670ded3180080ed9cc246d2828"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_parse_external_entity" ref="1471e0670ded3180080ed9cc246d2828" args="(FAXPP_Parser *parser, FAXPP_EntityType type, void *buffer, unsigned int length, unsigned int done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_parse_external_entity           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupts parsing to parse the external entity in the given buffer. 
<p>
Any parsing that was previously underway will continue when the external entity has been parsed. This method is usually called when an ENTITY_REFERENCE_EVENT is encountered with a non-null public or system identifier, in order to parse the external entity it points to.<p>
The buffer provided must remain valid and unchanged during the time that the parser is using it, since a copy of it is <em>not</em> made. The user remains responsible for deleting the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the start of the buffer to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the given buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>Set to non-zero if this is the last buffer from the external entity</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="afe116d82fe02a8266929d39b6ec0409"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_parse_external_entity_file" ref="afe116d82fe02a8266929d39b6ec0409" args="(FAXPP_Parser *parser, FAXPP_EntityType type, FILE *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_parse_external_entity_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupts parsing to parse the external entity from the given file. 
<p>
Any parsing that was previously underway will continue when the external entity has been parsed. This method is usually called when an ENTITY_REFERENCE_EVENT is encountered with a non-null public or system identifier, in order to parse the external entity it points to.<p>
The file provided must remain valid during the time that the parser is using it. The user remains responsible for closing the file after parsing has ended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file descriptor of the file to parse</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="255d9071f6a54574c886d1fd1db4f29e"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_parse_external_entity_callback" ref="255d9071f6a54574c886d1fd1db4f29e" args="(FAXPP_Parser *parser, FAXPP_EntityType type, FAXPP_ReadCallback callback, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_parse_external_entity_callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupts parsing to parse the external entity using the given read callback. 
<p>
Any parsing that was previously underway will continue when the external entity has been parsed. This method is usually called when an ENTITY_REFERENCE_EVENT is encountered with a non-null public or system identifier, in order to parse the external entity it points to.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The read callback function to use to retrieve the parse input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data to be passed to the callback function when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="entity__resolver_8c-example.html#a5">entity_resolver.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="f55413e143d7a8aa424a0004e7cb351e"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_release_buffer" ref="f55413e143d7a8aa424a0004e7cb351e" args="(FAXPP_Parser *parser, void **buffer_position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_release_buffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>buffer_position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instructs the parser to release any dependencies it has on it's current buffer. 
<p>
This is typically called on recieving a PREMATURE_END_OF_BUFFER error, before using <a class="el" href="structFAXPP__Parser.html#427686a8cf6337802d9d961d07a5606d" title="Provides a new buffer for the parser to continue parsing.">FAXPP_continue_parse()</a> to provide a new buffer. In this case, the buffer data between *buffer_position and the end of the buffer need to be copied into the start of the new buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer_position</em>&nbsp;</td><td>Set to a pointer in the current buffer that the tokenizer has tokenized up to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="427686a8cf6337802d9d961d07a5606d"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_continue_parse" ref="427686a8cf6337802d9d961d07a5606d" args="(FAXPP_Parser *parser, void *buffer, unsigned int length, unsigned int done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_continue_parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides a new buffer for the parser to continue parsing. 
<p>
<a class="el" href="structFAXPP__Parser.html#f55413e143d7a8aa424a0004e7cb351e" title="Instructs the parser to release any dependencies it has on it&#39;s current buffer...">FAXPP_release_buffer()</a> should have been called before this, and the remaining data in the old buffer transferred to the new one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the start of the buffer to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the given buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>Set to non-zero if this is the last buffer from the input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e743444bca7395430011eea17758211a"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_next_event" ref="e743444bca7395430011eea17758211a" args="(FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_next_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses the next event, placing the information for it into the current event. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Any error that occurs </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a9">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="4dce77addd1cba6869c6a07733b939cc"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_get_current_event" ref="4dce77addd1cba6869c6a07733b939cc" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFAXPP__Event.html">FAXPP_Event</a> * FAXPP_get_current_event           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current event produced by the parser when <a class="el" href="structFAXPP__Parser.html#e743444bca7395430011eea17758211a" title="Parses the next event, placing the information for it into the current event.">FAXPP_next_event()</a> was called. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current event </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a10">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="d3929884306c99be9a2786936e5c7c77"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_lookup_namespace_uri" ref="d3929884306c99be9a2786936e5c7c77" args="(const FAXPP_Parser *parser, const FAXPP_Text *prefix, FAXPP_Text *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_lookup_namespace_uri           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up the given prefix in the parser's namespace mappings, returning the namespace URI in the uri parameter. 
<p>
This method will not work correctly if the NO_CHECKS_PARSE_MODE is used, since the namespace mappings are not maintained in this mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix to loookup </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>uri</em>&nbsp;</td><td>The URI that the prefix maps to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NO_URI_FOR_PREFIX</em>&nbsp;</td><td>If a URI cannot be found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c35b9fb452dc8b33c173543f83d1837d"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_get_nesting_level" ref="c35b9fb452dc8b33c173543f83d1837d" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FAXPP_get_nesting_level           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current element nesting level in the XML document. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current nesting level </dd></dl>

</div>
</div><p>
<a class="anchor" name="81aff48f3f81c0ea684b3260b2cd8b74"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_get_error_line" ref="81aff48f3f81c0ea684b3260b2cd8b74" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FAXPP_get_error_line           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the line that the current error occured on. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The line number </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a13">parser_example.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="d39353aed0a2cd0ddaccfb910f9220d1"></a><!-- doxytag: member="FAXPP_Parser::FAXPP_get_error_column" ref="d39353aed0a2cd0ddaccfb910f9220d1" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FAXPP_get_error_column           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the column that the current error occured on. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The column number </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="parser__example_8c-example.html#a14">parser_example.c</a>.</dl>
</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="parser_8h-source.html">parser.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 4 14:21:52 2008 for Faxpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>

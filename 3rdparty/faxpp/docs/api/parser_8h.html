<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Faxpp 0.3 Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<a style="float:right;" href="http://sourceforge.net/projects/faxpp"><img src="http://sflogo.sourceforge.net/sflogo.php?group_id=201903&amp;type=2" border="0" alt="SourceForge.net Logo" /></a>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>parser.h File Reference</h1><code>#include &lt;stdio.h&gt;</code><br>
<code>#include &quot;<a class="el" href="error_8h-source.html">error.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="transcode_8h-source.html">transcode.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="event_8h-source.html">event.h</a>&quot;</code><br>

<p>
<div class="dynheader">
Include dependency graph for parser.h:</div>
<div class="dynsection">
<p><center><img src="parser_8h__incl.png" border="0" usemap="#parser.h_map" alt=""></center>
<map name="parser.h_map">
<area shape="rect" href="error_8h.html" title="error.h" alt="" coords="88,82,144,106"><area shape="rect" href="transcode_8h.html" title="transcode.h" alt="" coords="168,82,256,106"><area shape="rect" href="event_8h.html" title="event.h" alt="" coords="280,82,344,106"><area shape="rect" href="text_8h.html" title="text.h" alt="" coords="285,156,339,180"></map>
</div>

<p>
<a href="parser_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef struct FAXPP_ParserEnv_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#9613a5701d20d93986cc892b23d79000">FAXPP_Parser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parser structure. Details of the structure are private.  <a href="#9613a5701d20d93986cc892b23d79000"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a> )(void *userData, void *buffer, unsigned int length)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function called when faxpp recieves a PREMATURE_END_OF_BUFFER error from the tokenizer.  <a href="#746f81bf3a4cee2761ee71ae616b02c2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#e933a0086290a065b22874d9eeb80a54">FAXPP_ExternalEntityCallback</a> )(void *userData, <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *base_uri, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *system_id, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *public_id)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function called when faxpp finds a reference to an external parsed entity.  <a href="#e933a0086290a065b22874d9eeb80a54"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268">FAXPP_ParseMode</a> { <a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268d004b8f407c61056f4291a1c057ae22d">NO_CHECKS_PARSE_MODE</a>, 
<a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a2687e9c3e71aee429cb43b5fc2fa0683605">WELL_FORMED_PARSE_MODE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of checks to perform whilst parsing.  <a href="parser_8h.html#767b2087623b27550e57d7c07418a268">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> { <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d57cacf79a97f72e59c5c46dc9e944a86c">EXTERNAL_PARSED_ENTITY</a> =  0, 
<a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5141a99a5f6378da3b42df2f1019e2663">EXTERNAL_SUBSET_ENTITY</a> =  1, 
<a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d57568c67eb3ffa2b97f0f7f2cefb20270">EXTERNAL_IN_MARKUP_ENTITY</a> =  2
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of external entity to parse.  <a href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#8bbd54a6e2d37f54b25ca1e986fc6b85">FAXPP_create_parser</a> (<a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268">FAXPP_ParseMode</a> mode, <a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a> encode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a parser object.  <a href="#8bbd54a6e2d37f54b25ca1e986fc6b85"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#88cad603c0583aaf87f1bfaadb5197c1">FAXPP_free_parser</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees a parser object.  <a href="#88cad603c0583aaf87f1bfaadb5197c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#2f0f57d3017672bbf89aebdd1c6a5b82">FAXPP_set_null_terminate</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, unsigned int boolean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether the parser will null terminate the strings in the event values.  <a href="#2f0f57d3017672bbf89aebdd1c6a5b82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#97d9fe261f063b0bd5d2b933f8ec9ed8">FAXPP_set_normalize_attrs</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, unsigned int boolean)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether the parser will normalize attributes values into a single string.  <a href="#97d9fe261f063b0bd5d2b933f8ec9ed8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#e100f97e382d89ef9e819adc4fd7550f">FAXPP_set_encode</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a> encode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the transcoder that the parser will use when encoding event values.  <a href="#e100f97e382d89ef9e819adc4fd7550f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#f86972fbc5e3115290c9a8840fc7d4e8">FAXPP_get_decode</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current FAXPP_DecodeFunction that the parser is using.  <a href="#f86972fbc5e3115290c9a8840fc7d4e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#071e23490ca525b178d0e2f8e7d8e918">FAXPP_set_decode</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a> decode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FAXPP_DecodeFunction that the parser uses to decode the XML document.  <a href="#071e23490ca525b178d0e2f8e7d8e918"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#b6f657afb016e6e81e830297ad1c2763">FAXPP_get_base_uri</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the base URI for the file currently being parsed.  <a href="#b6f657afb016e6e81e830297ad1c2763"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#d7abd90dc4bc29a4e5002a3486563593">FAXPP_set_base_uri</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *base_uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the base URI for the file currently being parsed.  <a href="#d7abd90dc4bc29a4e5002a3486563593"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#3f81757b5a659c174d5f6cb712a4d96c">FAXPP_set_base_uri_str</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, const char *base_uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the base URI for the file currently being parsed.  <a href="#3f81757b5a659c174d5f6cb712a4d96c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#421db983eba7bea2b4faac0d9e048e50">FAXPP_set_external_entity_callback</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#e933a0086290a065b22874d9eeb80a54">FAXPP_ExternalEntityCallback</a> callback, void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters a reference to an external parsed entity.  <a href="#421db983eba7bea2b4faac0d9e048e50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#7aa280c7b5a002c4a97ea8b99ffe7cab">FAXPP_init_parse</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, void *buffer, unsigned int length, unsigned int done)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the parser to parse the given buffer.  <a href="#7aa280c7b5a002c4a97ea8b99ffe7cab"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#1b6319866100a7fe51309bd548dd9d86">FAXPP_init_parse_file</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, FILE *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the parser to parse the given file.  <a href="#1b6319866100a7fe51309bd548dd9d86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#229ebc0c0fdd6adec059d009b1cf110b">FAXPP_init_parse_callback</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a> callback, void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the parser to parse using the given read callback.  <a href="#229ebc0c0fdd6adec059d009b1cf110b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#1471e0670ded3180080ed9cc246d2828">FAXPP_parse_external_entity</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, void *buffer, unsigned int length, unsigned int done)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts parsing to parse the external entity in the given buffer.  <a href="#1471e0670ded3180080ed9cc246d2828"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#afe116d82fe02a8266929d39b6ec0409">FAXPP_parse_external_entity_file</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, FILE *file)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts parsing to parse the external entity from the given file.  <a href="#afe116d82fe02a8266929d39b6ec0409"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#255d9071f6a54574c886d1fd1db4f29e">FAXPP_parse_external_entity_callback</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, <a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a> callback, void *userData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupts parsing to parse the external entity using the given read callback.  <a href="#255d9071f6a54574c886d1fd1db4f29e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#f55413e143d7a8aa424a0004e7cb351e">FAXPP_release_buffer</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, void **buffer_position)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instructs the parser to release any dependencies it has on it's current buffer.  <a href="#f55413e143d7a8aa424a0004e7cb351e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#427686a8cf6337802d9d961d07a5606d">FAXPP_continue_parse</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, void *buffer, unsigned int length, unsigned int done)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a new buffer for the parser to continue parsing.  <a href="#427686a8cf6337802d9d961d07a5606d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#e743444bca7395430011eea17758211a">FAXPP_next_event</a> (<a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses the next event, placing the information for it into the current event.  <a href="#e743444bca7395430011eea17758211a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <a class="el" href="structFAXPP__Event.html">FAXPP_Event</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#4dce77addd1cba6869c6a07733b939cc">FAXPP_get_current_event</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current event produced by the parser when <a class="el" href="parser_8h.html#e743444bca7395430011eea17758211a" title="Parses the next event, placing the information for it into the current event.">FAXPP_next_event()</a> was called.  <a href="#4dce77addd1cba6869c6a07733b939cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#d3929884306c99be9a2786936e5c7c77">FAXPP_lookup_namespace_uri</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *prefix, <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *uri)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Look up the given prefix in the parser's namespace mappings, returning the namespace URI in the uri parameter.  <a href="#d3929884306c99be9a2786936e5c7c77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#c35b9fb452dc8b33c173543f83d1837d">FAXPP_get_nesting_level</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current element nesting level in the XML document.  <a href="#c35b9fb452dc8b33c173543f83d1837d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#81aff48f3f81c0ea684b3260b2cd8b74">FAXPP_get_error_line</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the line that the current error occured on.  <a href="#81aff48f3f81c0ea684b3260b2cd8b74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="parser_8h.html#d39353aed0a2cd0ddaccfb910f9220d1">FAXPP_get_error_column</a> (const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the column that the current error occured on.  <a href="#d39353aed0a2cd0ddaccfb910f9220d1"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="e933a0086290a065b22874d9eeb80a54"></a><!-- doxytag: member="parser.h::FAXPP_ExternalEntityCallback" ref="e933a0086290a065b22874d9eeb80a54" args=")(void *userData, FAXPP_Parser *parser, FAXPP_EntityType type, const FAXPP_Text *base_uri, const FAXPP_Text *system_id, const FAXPP_Text *public_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a>(* <a class="el" href="parser_8h.html#e933a0086290a065b22874d9eeb80a54">FAXPP_ExternalEntityCallback</a>)(void *userData, <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *parser, <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a> type, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *base_uri, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *system_id, const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *public_id)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function called when faxpp finds a reference to an external parsed entity. 
<p>
The function should locate the entity using it's system and public indentifiers and call <a class="el" href="parser_8h.html#1471e0670ded3180080ed9cc246d2828" title="Interrupts parsing to parse the external entity in the given buffer.">FAXPP_parse_external_entity()</a>, <a class="el" href="parser_8h.html#255d9071f6a54574c886d1fd1db4f29e" title="Interrupts parsing to parse the external entity using the given read callback.">FAXPP_parse_external_entity_callback()</a> or <a class="el" href="parser_8h.html#afe116d82fe02a8266929d39b6ec0409" title="Interrupts parsing to parse the external entity from the given file.">FAXPP_parse_external_entity_file()</a> to parse the external entity. The base URI provided is the one supplied by the user using <a class="el" href="parser_8h.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a> or <a class="el" href="parser_8h.html#3f81757b5a659c174d5f6cb712a4d96c" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri_str()</a> for the file that the entity declaration was in.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data supplied to the <a class="el" href="parser_8h.html#421db983eba7bea2b4faac0d9e048e50" title="Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters...">FAXPP_set_external_entity_callback()</a> method </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>A pointer to the parser </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to locate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base_uri</em>&nbsp;</td><td>The base URI for the entity declaration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>system_id</em>&nbsp;</td><td>The entity's system identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>public_id</em>&nbsp;</td><td>The entity's public identifier</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>NO_ERROR on success, DONT_PARSE_EXTERNAL_ENTITY to return an unexpanded ENTITY_REFERENCE_EVENT event, otherwise another error code to halt parsing (most probably CANT_LOCATE_EXTERNAL_ENTITY).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="parser_8h.html#421db983eba7bea2b4faac0d9e048e50" title="Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters...">FAXPP_set_external_entity_callback()</a> </dd></dl>

<p>Definition at line <a class="el" href="parser_8h-source.html#l00135">135</a> of file <a class="el" href="parser_8h-source.html">parser.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="9613a5701d20d93986cc892b23d79000"></a><!-- doxytag: member="parser.h::FAXPP_Parser" ref="9613a5701d20d93986cc892b23d79000" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct FAXPP_ParserEnv_s <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The parser structure. Details of the structure are private. 
<p>

<p>Definition at line <a class="el" href="parser_8h-source.html#l00082">82</a> of file <a class="el" href="parser_8h-source.html">parser.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="746f81bf3a4cee2761ee71ae616b02c2"></a><!-- doxytag: member="parser.h::FAXPP_ReadCallback" ref="746f81bf3a4cee2761ee71ae616b02c2" args=")(void *userData, void *buffer, unsigned int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int(* <a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a>)(void *userData, void *buffer, unsigned int length)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The function called when faxpp recieves a PREMATURE_END_OF_BUFFER error from the tokenizer. 
<p>
The function should read the next chunk of input into the buffer provided, returning the length of the data read.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data supplied to the <a class="el" href="parser_8h.html#229ebc0c0fdd6adec059d009b1cf110b" title="Initialize the parser to parse using the given read callback.">FAXPP_init_parse_callback()</a> method </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer</em>&nbsp;</td><td>The buffer to read the data into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the buffer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of bytes read - this will be less than length if the end of the input is reached</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="parser_8h.html#229ebc0c0fdd6adec059d009b1cf110b" title="Initialize the parser to parse using the given read callback.">FAXPP_init_parse_callback()</a>, <a class="el" href="parser_8h.html#255d9071f6a54574c886d1fd1db4f29e" title="Interrupts parsing to parse the external entity using the given read callback.">FAXPP_parse_external_entity_callback()</a> </dd></dl>

<p>Definition at line <a class="el" href="parser_8h-source.html#l00114">114</a> of file <a class="el" href="parser_8h-source.html">parser.h</a>.</p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="186e6b576d5e1dae292c30e55abf97d5"></a><!-- doxytag: member="parser.h::FAXPP_EntityType" ref="186e6b576d5e1dae292c30e55abf97d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of external entity to parse. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="186e6b576d5e1dae292c30e55abf97d57cacf79a97f72e59c5c46dc9e944a86c"></a><!-- doxytag: member="EXTERNAL_PARSED_ENTITY" ref="186e6b576d5e1dae292c30e55abf97d57cacf79a97f72e59c5c46dc9e944a86c" args="" -->EXTERNAL_PARSED_ENTITY</em>&nbsp;</td><td>
An external parsed entity. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="186e6b576d5e1dae292c30e55abf97d5141a99a5f6378da3b42df2f1019e2663"></a><!-- doxytag: member="EXTERNAL_SUBSET_ENTITY" ref="186e6b576d5e1dae292c30e55abf97d5141a99a5f6378da3b42df2f1019e2663" args="" -->EXTERNAL_SUBSET_ENTITY</em>&nbsp;</td><td>
An external subset (DTD). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="186e6b576d5e1dae292c30e55abf97d57568c67eb3ffa2b97f0f7f2cefb20270"></a><!-- doxytag: member="EXTERNAL_IN_MARKUP_ENTITY" ref="186e6b576d5e1dae292c30e55abf97d57568c67eb3ffa2b97f0f7f2cefb20270" args="" -->EXTERNAL_IN_MARKUP_ENTITY</em>&nbsp;</td><td>
An external entity inside DTD markup. </td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="parser_8h-source.html#l00095">95</a> of file <a class="el" href="parser_8h-source.html">parser.h</a>.</p>

</div>
</div><p>
<a class="anchor" name="767b2087623b27550e57d7c07418a268"></a><!-- doxytag: member="parser.h::FAXPP_ParseMode" ref="767b2087623b27550e57d7c07418a268" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268">FAXPP_ParseMode</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of checks to perform whilst parsing. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="767b2087623b27550e57d7c07418a268d004b8f407c61056f4291a1c057ae22d"></a><!-- doxytag: member="NO_CHECKS_PARSE_MODE" ref="767b2087623b27550e57d7c07418a268d004b8f407c61056f4291a1c057ae22d" args="" -->NO_CHECKS_PARSE_MODE</em>&nbsp;</td><td>
Perform no additional checks above those performed by tokenization - using this mode, the parser will <b>not</b> be compliant with the XML specifications. 
<p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="767b2087623b27550e57d7c07418a2687e9c3e71aee429cb43b5fc2fa0683605"></a><!-- doxytag: member="WELL_FORMED_PARSE_MODE" ref="767b2087623b27550e57d7c07418a2687e9c3e71aee429cb43b5fc2fa0683605" args="" -->WELL_FORMED_PARSE_MODE</em>&nbsp;</td><td>
Perform the checks required of a well formed parser, as well as resolving namespace prefixes to their respective URIs. 
<p>
</td></tr>
</table>
</dl>

<p>Definition at line <a class="el" href="parser_8h-source.html#l00085">85</a> of file <a class="el" href="parser_8h-source.html">parser.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="427686a8cf6337802d9d961d07a5606d"></a><!-- doxytag: member="parser.h::FAXPP_continue_parse" ref="427686a8cf6337802d9d961d07a5606d" args="(FAXPP_Parser *parser, void *buffer, unsigned int length, unsigned int done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_continue_parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Provides a new buffer for the parser to continue parsing. 
<p>
<a class="el" href="parser_8h.html#f55413e143d7a8aa424a0004e7cb351e" title="Instructs the parser to release any dependencies it has on it&#39;s current buffer...">FAXPP_release_buffer()</a> should have been called before this, and the remaining data in the old buffer transferred to the new one.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the start of the buffer to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the given buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>Set to non-zero if this is the last buffer from the input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8bbd54a6e2d37f54b25ca1e986fc6b85"></a><!-- doxytag: member="parser.h::FAXPP_create_parser" ref="8bbd54a6e2d37f54b25ca1e986fc6b85" args="(FAXPP_ParseMode mode, FAXPP_Transcoder encode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> * FAXPP_create_parser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="parser_8h.html#767b2087623b27550e57d7c07418a268">FAXPP_ParseMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a>&nbsp;</td>
          <td class="paramname"> <em>encode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a parser object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>The type of checks the parser should perform </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encode</em>&nbsp;</td><td>The transcoder to use when encoding event values</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the parser object, or 0 if out of memory. </dd></dl>

</div>
</div><p>
<a class="anchor" name="88cad603c0583aaf87f1bfaadb5197c1"></a><!-- doxytag: member="parser.h::FAXPP_free_parser" ref="88cad603c0583aaf87f1bfaadb5197c1" args="(FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_free_parser           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees a parser object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to free </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b6f657afb016e6e81e830297ad1c2763"></a><!-- doxytag: member="parser.h::FAXPP_get_base_uri" ref="b6f657afb016e6e81e830297ad1c2763" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> * FAXPP_get_base_uri           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the base URI for the file currently being parsed. 
<p>
This is set by the user using <a class="el" href="parser_8h.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a> or <a class="el" href="parser_8h.html#3f81757b5a659c174d5f6cb712a4d96c" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri_str()</a>.<p>
The base URI returned will be in the encoding that it was provided in to the <a class="el" href="parser_8h.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current base URI </dd></dl>

</div>
</div><p>
<a class="anchor" name="4dce77addd1cba6869c6a07733b939cc"></a><!-- doxytag: member="parser.h::FAXPP_get_current_event" ref="4dce77addd1cba6869c6a07733b939cc" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structFAXPP__Event.html">FAXPP_Event</a> * FAXPP_get_current_event           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current event produced by the parser when <a class="el" href="parser_8h.html#e743444bca7395430011eea17758211a" title="Parses the next event, placing the information for it into the current event.">FAXPP_next_event()</a> was called. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current event </dd></dl>

</div>
</div><p>
<a class="anchor" name="f86972fbc5e3115290c9a8840fc7d4e8"></a><!-- doxytag: member="parser.h::FAXPP_get_decode" ref="f86972fbc5e3115290c9a8840fc7d4e8" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a> FAXPP_get_decode           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current FAXPP_DecodeFunction that the parser is using. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The decode function </dd></dl>

</div>
</div><p>
<a class="anchor" name="d39353aed0a2cd0ddaccfb910f9220d1"></a><!-- doxytag: member="parser.h::FAXPP_get_error_column" ref="d39353aed0a2cd0ddaccfb910f9220d1" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FAXPP_get_error_column           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the column that the current error occured on. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The column number </dd></dl>

</div>
</div><p>
<a class="anchor" name="81aff48f3f81c0ea684b3260b2cd8b74"></a><!-- doxytag: member="parser.h::FAXPP_get_error_line" ref="81aff48f3f81c0ea684b3260b2cd8b74" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FAXPP_get_error_line           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the line that the current error occured on. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The line number </dd></dl>

</div>
</div><p>
<a class="anchor" name="c35b9fb452dc8b33c173543f83d1837d"></a><!-- doxytag: member="parser.h::FAXPP_get_nesting_level" ref="c35b9fb452dc8b33c173543f83d1837d" args="(const FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int FAXPP_get_nesting_level           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current element nesting level in the XML document. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current nesting level </dd></dl>

</div>
</div><p>
<a class="anchor" name="7aa280c7b5a002c4a97ea8b99ffe7cab"></a><!-- doxytag: member="parser.h::FAXPP_init_parse" ref="7aa280c7b5a002c4a97ea8b99ffe7cab" args="(FAXPP_Parser *parser, void *buffer, unsigned int length, unsigned int done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_init_parse           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the parser to parse the given buffer. 
<p>
This will halt any parse that was already in progress.<p>
The buffer provided must remain valid and unchanged during the time that the parser is using it, since a copy of it is <em>not</em> made. The user remains responsible for deleting the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the start of the buffer to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the given buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>Set to non-zero if this is the last buffer from the input</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="229ebc0c0fdd6adec059d009b1cf110b"></a><!-- doxytag: member="parser.h::FAXPP_init_parse_callback" ref="229ebc0c0fdd6adec059d009b1cf110b" args="(FAXPP_Parser *parser, FAXPP_ReadCallback callback, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_init_parse_callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the parser to parse using the given read callback. 
<p>
This will halt any parse that was already in progress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The read callback function to use to retrieve the parse input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data to be passed to the callback function when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1b6319866100a7fe51309bd548dd9d86"></a><!-- doxytag: member="parser.h::FAXPP_init_parse_file" ref="1b6319866100a7fe51309bd548dd9d86" args="(FAXPP_Parser *parser, FILE *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_init_parse_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the parser to parse the given file. 
<p>
This will halt any parse that was already in progress.<p>
The file provided must remain valid during the time that the parser is using it. The user remains responsible for closing the file after parsing has ended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file descriptor of the file to parse</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d3929884306c99be9a2786936e5c7c77"></a><!-- doxytag: member="parser.h::FAXPP_lookup_namespace_uri" ref="d3929884306c99be9a2786936e5c7c77" args="(const FAXPP_Parser *parser, const FAXPP_Text *prefix, FAXPP_Text *uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_lookup_namespace_uri           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td>
          <td class="paramname"> <em>uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Look up the given prefix in the parser's namespace mappings, returning the namespace URI in the uri parameter. 
<p>
This method will not work correctly if the NO_CHECKS_PARSE_MODE is used, since the namespace mappings are not maintained in this mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>The prefix to loookup </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>uri</em>&nbsp;</td><td>The URI that the prefix maps to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NO_URI_FOR_PREFIX</em>&nbsp;</td><td>If a URI cannot be found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e743444bca7395430011eea17758211a"></a><!-- doxytag: member="parser.h::FAXPP_next_event" ref="e743444bca7395430011eea17758211a" args="(FAXPP_Parser *parser)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_next_event           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses the next event, placing the information for it into the current event. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Any error that occurs </dd></dl>

</div>
</div><p>
<a class="anchor" name="1471e0670ded3180080ed9cc246d2828"></a><!-- doxytag: member="parser.h::FAXPP_parse_external_entity" ref="1471e0670ded3180080ed9cc246d2828" args="(FAXPP_Parser *parser, FAXPP_EntityType type, void *buffer, unsigned int length, unsigned int done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_parse_external_entity           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupts parsing to parse the external entity in the given buffer. 
<p>
Any parsing that was previously underway will continue when the external entity has been parsed. This method is usually called when an ENTITY_REFERENCE_EVENT is encountered with a non-null public or system identifier, in order to parse the external entity it points to.<p>
The buffer provided must remain valid and unchanged during the time that the parser is using it, since a copy of it is <em>not</em> made. The user remains responsible for deleting the buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buffer</em>&nbsp;</td><td>A pointer to the start of the buffer to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the given buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>Set to non-zero if this is the last buffer from the external entity</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="255d9071f6a54574c886d1fd1db4f29e"></a><!-- doxytag: member="parser.h::FAXPP_parse_external_entity_callback" ref="255d9071f6a54574c886d1fd1db4f29e" args="(FAXPP_Parser *parser, FAXPP_EntityType type, FAXPP_ReadCallback callback, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_parse_external_entity_callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#746f81bf3a4cee2761ee71ae616b02c2">FAXPP_ReadCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupts parsing to parse the external entity using the given read callback. 
<p>
Any parsing that was previously underway will continue when the external entity has been parsed. This method is usually called when an ENTITY_REFERENCE_EVENT is encountered with a non-null public or system identifier, in order to parse the external entity it points to.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The read callback function to use to retrieve the parse input </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The user data to be passed to the callback function when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="afe116d82fe02a8266929d39b6ec0409"></a><!-- doxytag: member="parser.h::FAXPP_parse_external_entity_file" ref="afe116d82fe02a8266929d39b6ec0409" args="(FAXPP_Parser *parser, FAXPP_EntityType type, FILE *file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_parse_external_entity_file           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#186e6b576d5e1dae292c30e55abf97d5">FAXPP_EntityType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>file</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupts parsing to parse the external entity from the given file. 
<p>
Any parsing that was previously underway will continue when the external entity has been parsed. This method is usually called when an ENTITY_REFERENCE_EVENT is encountered with a non-null public or system identifier, in order to parse the external entity it points to.<p>
The file provided must remain valid during the time that the parser is using it. The user remains responsible for closing the file after parsing has ended.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td>The parser to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>The type of external entity to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td>The file descriptor of the file to parse</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>UNSUPPORTED_ENCODING</em>&nbsp;</td><td>If the encoding sniffing algorithm cannot recognize the encoding of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f55413e143d7a8aa424a0004e7cb351e"></a><!-- doxytag: member="parser.h::FAXPP_release_buffer" ref="f55413e143d7a8aa424a0004e7cb351e" args="(FAXPP_Parser *parser, void **buffer_position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_release_buffer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>buffer_position</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Instructs the parser to release any dependencies it has on it's current buffer. 
<p>
This is typically called on recieving a PREMATURE_END_OF_BUFFER error, before using <a class="el" href="parser_8h.html#427686a8cf6337802d9d961d07a5606d" title="Provides a new buffer for the parser to continue parsing.">FAXPP_continue_parse()</a> to provide a new buffer. In this case, the buffer data between *buffer_position and the end of the buffer need to be copied into the start of the new buffer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buffer_position</em>&nbsp;</td><td>Set to a pointer in the current buffer that the tokenizer has tokenized up to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d7abd90dc4bc29a4e5002a3486563593"></a><!-- doxytag: member="parser.h::FAXPP_set_base_uri" ref="d7abd90dc4bc29a4e5002a3486563593" args="(FAXPP_Parser *parser, const FAXPP_Text *base_uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_set_base_uri           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structFAXPP__Text.html">FAXPP_Text</a> *&nbsp;</td>
          <td class="paramname"> <em>base_uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the base URI for the file currently being parsed. 
<p>
This is passed to the FAXPP_ExternalEntityCallback set using <a class="el" href="parser_8h.html#421db983eba7bea2b4faac0d9e048e50" title="Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters...">FAXPP_set_external_entity_callback()</a>.<p>
A copy of the base_uri will be kept internally, so neither the <a class="el" href="structFAXPP__Text.html" title="The basic string type in faxpp.">FAXPP_Text</a> object nor the buffer it points to need exist after a call to <a class="el" href="parser_8h.html#d7abd90dc4bc29a4e5002a3486563593" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri()</a>. The encoding of the base URI is irrelevent to FAXPP - the base URI will be in the same encoding when it is passed back to the FAXPP_ExternalEntityCallback.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base_uri</em>&nbsp;</td><td>The base URI</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3f81757b5a659c174d5f6cb712a4d96c"></a><!-- doxytag: member="parser.h::FAXPP_set_base_uri_str" ref="3f81757b5a659c174d5f6cb712a4d96c" args="(FAXPP_Parser *parser, const char *base_uri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="error_8h.html#980ffef95fcc9e36273600c3611262c2">FAXPP_Error</a> FAXPP_set_base_uri_str           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>base_uri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the base URI for the file currently being parsed. 
<p>
This is passed to the FAXPP_ExternalEntityCallback set using <a class="el" href="parser_8h.html#421db983eba7bea2b4faac0d9e048e50" title="Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters...">FAXPP_set_external_entity_callback()</a>.<p>
A copy of the base_uri will be kept internally, so the string need not exist after a call to <a class="el" href="parser_8h.html#3f81757b5a659c174d5f6cb712a4d96c" title="Sets the base URI for the file currently being parsed.">FAXPP_set_base_uri_str()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>base_uri</em>&nbsp;</td><td>The base URI</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>OUT_OF_MEMORY</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NO_ERROR</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="071e23490ca525b178d0e2f8e7d8e918"></a><!-- doxytag: member="parser.h::FAXPP_set_decode" ref="071e23490ca525b178d0e2f8e7d8e918" args="(FAXPP_Parser *parser, FAXPP_DecodeFunction decode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_decode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="transcode_8h.html#79e6c201ed538ec059ac2515bef21ca0">FAXPP_DecodeFunction</a>&nbsp;</td>
          <td class="paramname"> <em>decode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the FAXPP_DecodeFunction that the parser uses to decode the XML document. 
<p>
This will typically be called when an encoding declaration is read, to switch to the correct decode function.<p>
This method can also be called after initialising the parser, to specify that the encoding for the document is known, and all other encoding hints should be ignored. Note that it is valid to call this method and proceed with a document parse when parser initialisation fails with the UNSUPPORTED_ENCODING error.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>decode</em>&nbsp;</td><td>The decode function </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e100f97e382d89ef9e819adc4fd7550f"></a><!-- doxytag: member="parser.h::FAXPP_set_encode" ref="e100f97e382d89ef9e819adc4fd7550f" args="(FAXPP_Parser *parser, FAXPP_Transcoder encode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_encode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFAXPP__Transcoder.html">FAXPP_Transcoder</a>&nbsp;</td>
          <td class="paramname"> <em>encode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the transcoder that the parser will use when encoding event values. 
<p>
Setting this parameter whilst a parse is in progress has undefined results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>encode</em>&nbsp;</td><td>The transcoder to use when encoding event values </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="421db983eba7bea2b4faac0d9e048e50"></a><!-- doxytag: member="parser.h::FAXPP_set_external_entity_callback" ref="421db983eba7bea2b4faac0d9e048e50" args="(FAXPP_Parser *parser, FAXPP_ExternalEntityCallback callback, void *userData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_external_entity_callback           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="parser_8h.html#e933a0086290a065b22874d9eeb80a54">FAXPP_ExternalEntityCallback</a>&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the FAXPP_ExternalEntityCallback that the parser will call when it encounters a reference to an external parsed entity. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback</em>&nbsp;</td><td>The callback function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData</em>&nbsp;</td><td>The usuer data passed when the function is called </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="97d9fe261f063b0bd5d2b933f8ec9ed8"></a><!-- doxytag: member="parser.h::FAXPP_set_normalize_attrs" ref="97d9fe261f063b0bd5d2b933f8ec9ed8" args="(FAXPP_Parser *parser, unsigned int boolean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_normalize_attrs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>boolean</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the parser will normalize attributes values into a single string. 
<p>
This option is off by default for NO_CHECKS_PARSE_MODE, and on for other parser modes.<p>
The XML specification requires conformant parsers to normalize attribute values by expanding entity references and turning all whitespace to &amp;x20; characters. This option will have no effect on a parser in NO_CHECKS_PARSE_MODE, since this mode will never normalize attribute values.<p>
Setting this parameter whilst a parse is in progress has undefined results.<p>
Normalizing attribute values will involve copying the strings, and so will be slower where copying strings was not otherwise necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boolean</em>&nbsp;</td><td>Whether to normalize attribute values </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2f0f57d3017672bbf89aebdd1c6a5b82"></a><!-- doxytag: member="parser.h::FAXPP_set_null_terminate" ref="2f0f57d3017672bbf89aebdd1c6a5b82" args="(FAXPP_Parser *parser, unsigned int boolean)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FAXPP_set_null_terminate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structFAXPP__Parser.html">FAXPP_Parser</a> *&nbsp;</td>
          <td class="paramname"> <em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>boolean</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets whether the parser will null terminate the strings in the event values. 
<p>
The default is not to null terminate strings, as this is generally more efficient.<p>
Setting this parameter whilst a parse is in progress has undefined results.<p>
Null terminating the event strings will involve copying the strings, and so will be slower where copying strings was not otherwise necessary. The <a class="el" href="structFAXPP__Text.html#0020dd9d52a282ad375ab35352b262ca" title="The length of the string in bytes.">FAXPP_Text::len</a> field will not include the null in it's count of bytes, and so will be identical whether the parser is null terminating strings or not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>parser</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>boolean</em>&nbsp;</td><td>Whether to null terminate the event strings or not </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Dec 4 14:21:51 2008 for Faxpp by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
